// TODO: Segmentation, Classification, Bounds, Ogrid filtering

#include "Classification.hpp"
Classification::Classification(ros::NodeHandle *nh)
{
  nh_ = nh;

  // TODO: Algorithms to filter pointcloud and possibly some classification scheme
}

pcl::PointCloud<pcl::PointXYZI>::Ptr Classification::filtered(pcl::PointCloud<pcl::PointXYZI>::ConstPtr pointCloud)
{
  pcl::PointCloud<pcl::PointXYZI>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZI>);
  if (pointCloud->points.size() < 1)
    return cloud_filtered;
  pcl::StatisticalOutlierRemoval<pcl::PointXYZI> sor;
  sor.setInputCloud(pointCloud);
  sor.setMeanK(75);
  sor.setStddevMulThresh(.75);
  sor.filter(*cloud_filtered);
  return cloud_filtered;
}

// Get first incidient point in a ray. If no such point exist, return the starting point of the ray
cv::Point2d Classification::get_first_hit(cv::Mat &mat_ogrid, cv::Point2d start, float theta, int max_dis = 100)
{
  cv::Point2d vec_d_theta(cos(theta), sin(theta));
  for (int i = 0; i < max_dis; ++i)
  {
    cv::Point2d p_on_ray = vec_d_theta * i + start;
    if (mat_ogrid.at<uchar>(p_on_ray.y, p_on_ray.x) == 99)
    {
      return p_on_ray;
    }
  }
  return start;
}

/*
  Get first incident points in rays that are generated by changing angles and forming a circle.
  Then draw a filled polygon using those incident points
*/
void Classification::zonify(cv::Mat &mat_ogrid, float resolution, const tf::StampedTransform &transform)
{
  // Sub's position relative to the ogrid
  cv::Point2d where_sub = cv::Point2d(transform.getOrigin().x() / resolution + mat_ogrid.cols / 2,
                                      transform.getOrigin().y() / resolution + mat_ogrid.rows / 2);

  // List of intersections
  std::list<cv::Point> intersections;
  intersections.push_back(where_sub);

  // Find first hits in a circulering ray
  for (float d_theta = 0.f; d_theta <= 6.28; d_theta += 0.05)
  {
    cv::Point2d p_on_ray = get_first_hit(mat_ogrid, where_sub, d_theta);
    intersections.push_back(cv::Point(p_on_ray.x, p_on_ray.y));
  }

  // Convert data types to the ones OpenCV wants
  std::vector<cv::Point> v{ std::make_move_iterator(std::begin(intersections)),
                            std::make_move_iterator(std::end(intersections)) };
  const cv::Point *pts = (const cv::Point *)cv::Mat(v).data;
  int npts = cv::Mat(v).rows;
  cv::fillPoly(mat_ogrid, &pts, &npts, 1, cv::Scalar(0));
}
