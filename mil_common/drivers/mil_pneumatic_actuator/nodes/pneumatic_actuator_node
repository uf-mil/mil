#!/usr/bin/env python3
import threading

import rclpy
from rclpy.node import Node
from mil_pneumatic_actuator import PneumaticActuatorDriver, PneumaticActuatorDriverError
from mil_pneumatic_actuator.srv import SetValve
from serial import SerialException
from std_srvs.srv import Trigger

lock = threading.Lock()


class Actuator:
    """
    Encapsulates the configuration for an actuator, which can contain up to 2 valves
    and can be of 'set' or 'pulse' type.
    """

    def __init__(
        self,
        type_str,
        open_id,
        open_default,
        close_id,
        close_default,
        pulse_time,
    ):
        self.pulse_time = pulse_time
        self.type = type_str
        self.open_id = open_id
        self.open_default = open_default
        self.close_id = close_id
        self.close_default = close_default

    @classmethod
    def from_dict(cls, config):
        if isinstance(config, int):
            return cls.from_int(config)
        type_str = config["type"]
        pulse_time = config.get("pulse_time")
        open_id = config["ports"]["open_port"]["id"]
        open_default = config["ports"]["open_port"]["default"]
        if "close_port" in config["ports"]:
            close_id = config["ports"]["close_port"]["id"]
            close_default = config["ports"]["close_port"]["default"]
            return cls(
                type_str,
                open_id,
                open_default,
                close_id,
                close_default,
                pulse_time,
            )
        return cls(type_str, open_id, open_default, -1, 0, pulse_time)

    @classmethod
    def from_int(cls, valve_id):
        return cls("set", valve_id, 0, -1, 0, 0.0)


class PneumaticActuatorNode(Node):
    """
    Allows high level ROS code to interface with the pneumatics board.
    """

    def __init__(self):
        super().__init__('pneumatic_actuator_driver')
        self.baud_rate = self.get_parameter_or('baud_rate', 9600).value
        self.port = self.get_parameter_or('port', '/dev/ttyUSB0').value
        self.is_simulation = self.get_parameter_or('is_simulation', False).value

        self.connected = False
        while not self.connected:
            self.reconnect_and_ping()
            if not self.connected:
                rclpy.sleep(1)

        actuators = self.get_parameter_or('actuators', {}).value
        self.actuators = {}
        for a in actuators:
            self.actuators[a] = Actuator.from_dict(actuators[a])

        self.reset()

        self.create_service(SetValve, '~actuate', self.got_service_request)
        self.create_service(Trigger, '~reset', self.reset)

        self.timer = self.create_timer(3.0, self.reconnect_and_ping)

    def reset(self, *args):
        for actuator in self.actuators.values():
            self.set_port(actuator.open_id, actuator.open_default)
            self.set_port(actuator.close_id, actuator.close_default)
        self.get_logger().info("Valves set to default state")
        return {"success": True}

    def set_raw_valve(self, srv):
        self.get_logger().info(
            "Setting valve {} to {}".format(
                srv.actuator,
                "open" if srv.opened else "closed",
            ),
        )
        self.set_port(int(srv.actuator), srv.opened)
        return {"success": True}

    def set_port(self, port, state):
        if port == -1:
            return False
        try:
            self.driver.set_port(port, state)
        except (PneumaticActuatorDriverError, SerialException) as e:
            self.get_logger().error(f"Error interfacing with actuator board: {e}")
            return False
        return True

    def reconnect_and_ping(self, *args):
        if not self.connected:
            try:
                self.driver = PneumaticActuatorDriver(
                    self.port,
                    baud=self.baud_rate,
                    simulated=self.is_simulation,
                )
            except SerialException as e:
                self.get_logger().warn(e)
                return

        try:
            self.driver.ping()
        except (PneumaticActuatorDriverError, SerialException) as e:
            self.get_logger().warn(f"Could not ping actuator board: {e}")
            if self.connected:
                self.get_logger().error("Board not responding to pings. Disconnected.")
                self.connected = False
            return

        if not self.connected:
            self.get_logger().info("Board connected!")
            self.connected = True

    def got_service_request(self, srv):
        if not self.connected:
            return {"success": False, "message": "board not connected"}
        try:
            int(srv.actuator)
            return self.set_raw_valve(srv)
        except ValueError:
            pass

        if srv.actuator not in self.actuators:
            return {"success": False, "message": "actuator not registered"}
        actuator = self.actuators[srv.actuator]

        if actuator.type == "pulse":
            self.get_logger().info(f"Pulsing {srv.actuator} for {actuator.pulse_time}s")
            self.set_port(actuator.open_id, not actuator.open_default)
            self.set_port(actuator.close_id, not actuator.close_default)

            def close(*args):
                self.set_port(actuator.open_id, actuator.open_default)
                self.set_port(actuator.close_id, actuator.close_default)

            self.create_timer(actuator.pulse_time, close, oneshot=True)

        elif actuator.type == "set":
            if srv.opened:
                self.get_logger().info(f"Opening {srv.actuator}")
                self.set_port(actuator.open_id, True)
                self.set_port(actuator.close_id, False)
            else:
                self.get_logger().info(f"Closing {srv.actuator}")
                self.set_port(actuator.open_id, False)
                self.set_port(actuator.close_id, True)
        return {"success": True}


def main(args=None):
    rclpy.init(args=args)
    node = PneumaticActuatorNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == "__main__":
    main()
