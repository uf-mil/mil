// TODO: Segmentation, Classification, Bounds, Ogrid filtering

#include "Classification.hpp"

#include "OGridGen.hpp"  // for params extern struct
Classification::Classification(ros::NodeHandle *nh)
{
  nh_ = nh;
}

pcl::PointCloud<pcl::PointXYZI>::Ptr Classification::filtered(pcl::PointCloud<pcl::PointXYZI>::ConstPtr pointCloud)
{
  pcl::PointCloud<pcl::PointXYZI>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZI>);
  if (pointCloud->points.size() < 1)
    return cloud_filtered;
  pcl::StatisticalOutlierRemoval<pcl::PointXYZI> sor;
  sor.setInputCloud(pointCloud);
  sor.setMeanK(params.statistical_mean_k);
  sor.setStddevMulThresh(params.statistical_stddev_mul_thresh);
  sor.filter(*cloud_filtered);
  return cloud_filtered;
}

std::vector<pcl::PointIndices> Classification::clustering(pcl::PointCloud<pcl::PointXYZI>::ConstPtr pointCloud)
{
  if (pointCloud->size() < 1)
    return std::vector<pcl::PointIndices>();
  pcl::search::KdTree<pcl::PointXYZI>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZI>);
  tree->setInputCloud(pointCloud);

  std::vector<pcl::PointIndices> cluster_indices;
  pcl::EuclideanClusterExtraction<pcl::PointXYZI> ec;

  ec.setClusterTolerance(params.cluster_tolerance_m);
  ec.setMinClusterSize(params.cluster_min_num_points);
  ec.setMaxClusterSize(params.cluster_max_num_points);
  ec.setSearchMethod(tree);
  ec.setInputCloud(pointCloud);
  ec.extract(cluster_indices);

  return cluster_indices;
}
// Get first incidient point in a ray. If no such point exist, return the starting point of the ray
cv::Point2d Classification::get_first_hit(cv::Mat &mat_ogrid, cv::Point2d start, float theta, int max_dis = 100)
{
  cv::Rect rect(cv::Point(0, 0), mat_ogrid.size());
  cv::Point2d vec_d_theta(cos(theta), sin(theta));

  // loop through all points in a ray
  for (int i = 0; i < max_dis; ++i)
  {
    cv::Point2d p_on_ray = vec_d_theta * i + start;
    if (!rect.contains(p_on_ray))
      return start;
    // is this an object (occupied region)?
    if (mat_ogrid.at<float>(p_on_ray.y, p_on_ray.x) > certainty_as_hit_)
    {
      // mark everything behind the object as unknown
      for (int j = i + hit_buffer_; j < max_dis; ++j)
      {
        cv::Point2d cp_on_ray = vec_d_theta * j + start;
        if (!rect.contains(cp_on_ray))
          break;
        mat_ogrid.at<float>(cp_on_ray.y, cp_on_ray.x) = .5;
      }
      // degrade things infront of the object as unoccupied
      for (int j = 0; j < i; ++j)
      {
        cv::Point2d cp_on_ray = vec_d_theta * j + start;
        if (!rect.contains(cp_on_ray))
          break;
        if (mat_ogrid.at<float>(cp_on_ray.y, cp_on_ray.x) > 0 &&
            mat_ogrid.at<float>(cp_on_ray.y, cp_on_ray.x) < uncertainty_as_hit_)
        {
          mat_ogrid.at<float>(cp_on_ray.y, cp_on_ray.x) -= not_hit_degrade_;
        }
      }
      return p_on_ray;
    }
  }

  return start;
}

/*
  Get first incident points in rays that are generated by changing angles and forming a circle.
  Then draw a filled polygon using those incident points
*/
void Classification::zonify(cv::Mat &mat_ogrid, float resolution, const tf::StampedTransform &transform,
                            cv::Point &mat_origin)
{
  // Runtime debugging
  nh_->param<float>("/ogrid_pointcloud/certainty_as_hit", certainty_as_hit_, 0.95);
  nh_->param<int>("/ogrid_pointcloud/hit_buffer", hit_buffer_, 5);
  nh_->param<float>("/ogrid_pointcloud/uncertainty_as_hit", uncertainty_as_hit_, 0.95);
  nh_->param<float>("/ogrid_pointcloud/not_hit_degrade", not_hit_degrade_, 0.01);
  // Sub's position relative to the ogrid
  cv::Point2d where_sub =
      cv::Point2d(transform.getOrigin().x() / resolution + mat_ogrid.cols / 2 - mat_origin.x / resolution,
                  transform.getOrigin().y() / resolution + mat_ogrid.rows / 2 - mat_origin.y / resolution);

  // Find first hits in an expanding circle
  for (float d_theta = 0.f; d_theta <= 2 * CV_PI; d_theta += 0.005)
  {
    cv::Point2d p_on_ray = get_first_hit(mat_ogrid, where_sub, d_theta, mat_ogrid.cols);
  }
}
